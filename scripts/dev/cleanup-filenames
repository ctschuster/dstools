#!/usr/bin/perl
########################################################################
# Script:  cleanup-filenames
#
# This function takes a file or directory name and mutates the name to
# be acceptable for general use, so usable in unix/windows/s3.  At this
# time the rule in place is that to replace any spacing with underscores.
# Additional rules may be added over time.
# There is NO treatment at this time for simplifying extensions or
# dealing with length of filenames.
# Considering for example:
#     .tar.gz   -> .tgz
#     .fa/.fas  -> .fasta
#     .fq       -> .fastq
# The scope of this treatment of filenames ONLY deals with UTF8
# characters, not supporting full unicode.
########################################################################

use strict;
use warnings;


########################################################################
sub filename_cleanup($)
{
    my ($fold) = @_;
    my $fnew = $fold;
    $fnew =~ s/\s/_/g;

    if ($fnew ne $fold) {
        print "attempting to rewrite:\n";
        print "<< '$fold'\n";
        print ">> '$fnew'\n";
        if (-e $fnew) {
            warn "file $fold rename collision with existing file";
        } else {
            rename $fold, $fnew;
        }
    }
}

########################################################################
sub standardize_filenames
{
    my ($fold) = @_;
    filename_cleanup($fold);
    if (-d $fold) {
        standardize_filenames($_) for <$fold/*>;
    }
}

########################################################################
if (!@ARGV) {
    my $progname = basename $0;
    print "usage: $progname <file-or-dir> [...]";
    exit 0;
}
foreach my $file (@ARGV) {
    standardize_filenames($file);
}
